// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios16.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-bare-slash-regex -module-name libxetex
import CoreText
import Foundation
import Swift
import UniformTypeIdentifiers
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_inheritsConvenienceInitializers @objc public class GlobalConfig : ObjectiveC.NSObject {
  @libxetex.AtomicValue @objc @_projectedValueProperty($usingPDFCompression) public var usingPDFCompression: Swift.Bool {
    @objc get
    @objc set
    _modify
  }
  public var $usingPDFCompression: ((Swift.Bool) throws -> Swift.Bool) throws -> () {
    get
  }
  @objc public static let share: libxetex.GlobalConfig
  @objc override dynamic public init()
  @objc deinit
}
@_Concurrency.MainActor public protocol FileQueryProvider : AnyObject {
  @_Concurrency.MainActor var texliveResources: libxetex.TeXResources { get }
  @_Concurrency.MainActor var dynamicSearchResources: [Foundation.URL] { get set }
  @_Concurrency.MainActor var texProjectDirectory: Foundation.URL? { get set }
  @_Concurrency.MainActor func search(for fileName: Swift.String, with type: libxetex.TeXFileType) async -> libxetex.FileQueryResult
  @_Concurrency.MainActor func setResources(texlive texmfRootDirectory: Foundation.URL) async throws
  @_Concurrency.MainActor func checkTeXResource(for texResourceURL: Foundation.URL) -> Swift.Bool
}
public enum FileQueryResult {
  case dynamic(url: Foundation.URL)
  case texProject(url: Foundation.URL)
  case texlive(url: Foundation.URL)
  case notFound
}
@objc @_Concurrency.MainActor public class TeXFileQuerier : ObjectiveC.NSObject, libxetex.FileQueryProvider {
  @objc @_Concurrency.MainActor public static func setTeXResource(url: Foundation.URL)
  @objc @_Concurrency.MainActor public static func share() -> libxetex.TeXFileQuerier
  @objc @_Concurrency.MainActor public static func fontQuerier() -> libxetex.TeXFontQuerier
  @_Concurrency.MainActor public static var usingDetailedLog: Swift.Bool
  public enum QueryError : Swift.Error {
    case dataReadFailure
    public static func == (a: libxetex.TeXFileQuerier.QueryError, b: libxetex.TeXFileQuerier.QueryError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor public var texliveResources: libxetex.TeXResources
  @objc @_Concurrency.MainActor public var formatFileURL: Foundation.URL? {
    @objc get
    @objc set
  }
  @objc @libxetex.AtomicValue @_projectedValueProperty($dynamicSearchResources) @_Concurrency.MainActor public var dynamicSearchResources: [Foundation.URL] {
    @objc get
    @objc set
    _modify
  }
  @_Concurrency.MainActor public var $dynamicSearchResources: (([Foundation.URL]) throws -> [Foundation.URL]) throws -> () {
    get
  }
  @objc @libxetex.AtomicValue @_projectedValueProperty($texProjectDirectory) @_Concurrency.MainActor public var texProjectDirectory: Foundation.URL? {
    @objc get
    @objc set
    _modify
  }
  @_Concurrency.MainActor public var $texProjectDirectory: ((Foundation.URL?) throws -> Foundation.URL?) throws -> () {
    get
  }
  @_Concurrency.MainActor public init(texlive texmfRootDirectory: Foundation.URL)
  @available(*, deprecated)
  @_Concurrency.MainActor public func setResources(texlive texmfRootDirectory: Foundation.URL)
  @_Concurrency.MainActor public func checkTeXResource(for texResourceURL: Foundation.URL) -> Swift.Bool
  @objc @_Concurrency.MainActor public func search(for fileName: Swift.String, format type: libxetex.TeXFileType) -> Foundation.URL?
  @objc @_Concurrency.MainActor open func variableValue(for key: Swift.String) -> Swift.String?
  @_Concurrency.MainActor public func search(for fileName: Swift.String, with type: libxetex.TeXFileType) -> libxetex.FileQueryResult
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class FontInfoResult : ObjectiveC.NSObject {
  @objc final public let path: Swift.String
  @objc final public let extensionName: Swift.String
  @objc final public let postScriptName: Swift.String
  @objc final public let fullNames: [Swift.String]
  @objc final public let familyNames: [Swift.String]
  @objc final public let styleNames: [Swift.String]
  @objc final public let index: Swift.Int
  @objc deinit
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor @objc public class TeXFontQuerier : ObjectiveC.NSObject {
  @_Concurrency.MainActor public func updateFontCache()
  @objc @_Concurrency.MainActor public func searchFont(name: Swift.String) -> libxetex.FontInfoResult?
  @objc @_Concurrency.MainActor public func searchSameFamily(for postScriptName: Swift.String) -> [libxetex.FontInfoResult]
  @objc deinit
}
extension libxetex.TeXFontQuerier {
  nonisolated public static func searchSystemFont(name: Swift.String, attribute: CoreText.CTFont.Attribute) -> [CoreText.CTFontDescriptor]
  nonisolated public static func searchSystemFont(name: Swift.String) -> CoreText.CTFontDescriptor?
  nonisolated public static func searchSystemFontIndex(for fontDescriptor: CoreText.CTFontDescriptor) -> Swift.Int
  nonisolated public static func getAllSameFamilyFont(for fontDescriptor: CoreText.CTFontDescriptor) -> [CoreText.CTFontDescriptor]
}
@objc public enum TeXFileType : Swift.Int, Swift.Hashable {
  case kpse_gf_format
  case kpse_pk_format
  case kpse_any_glyph_format
  case kpse_tfm_format
  case kpse_afm_format
  case kpse_base_format
  case kpse_bib_format
  case kpse_bst_format
  case kpse_cnf_format
  case kpse_db_format
  case kpse_fmt_format
  case kpse_fontmap_format
  case kpse_mem_format
  case kpse_mf_format
  case kpse_mfpool_format
  case kpse_mft_format
  case kpse_mp_format
  case kpse_mppool_format
  case kpse_mpsupport_format
  case kpse_ocp_format
  case kpse_ofm_format
  case kpse_opl_format
  case kpse_otp_format
  case kpse_ovf_format
  case kpse_ovp_format
  case kpse_pict_format
  case kpse_tex_format
  case kpse_texdoc_format
  case kpse_texpool_format
  case kpse_texsource_format
  case kpse_tex_ps_header_format
  case kpse_troff_font_format
  case kpse_type1_format
  case kpse_vf_format
  case kpse_dvips_config_format
  case kpse_ist_format
  case kpse_truetype_format
  case kpse_type42_format
  case kpse_web2c_format
  case kpse_program_text_format
  case kpse_program_binary_format
  case kpse_miscfonts_format
  case kpse_web_format
  case kpse_cweb_format
  case kpse_enc_format
  case kpse_cmap_format
  case kpse_sfd_format
  case kpse_opentype_format
  case kpse_pdftex_config_format
  case kpse_lig_format
  case kpse_texmfscripts_format
  case kpse_lua_format
  case kpse_fea_format
  case kpse_cid_format
  case kpse_mlbib_format
  case kpse_mlbst_format
  case kpse_clua_format
  case kpse_ris_format
  case kpse_bltxml_format
  case kpse_last_format
  public var suffix: [Swift.String] {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct TeXResources {
  public var texmf_dist: Foundation.URL
  public var texmf_var: Foundation.URL
  public var texmf_config: Foundation.URL
  public init(texmf_dist: Foundation.URL, texmf_var: Foundation.URL, texmf_config: Foundation.URL)
  public init(root texmf_root_Directory: Foundation.URL)
}
extension CoreText.CTFont {
  public struct NameKey : Swift.Hashable, Swift.Equatable {
    public var rawValue: CoreFoundation.CFString
    public static let copyrightName: CoreText.CTFont.NameKey
    public static let familyName: CoreText.CTFont.NameKey
    public static let subFamilyName: CoreText.CTFont.NameKey
    public static let styleName: CoreText.CTFont.NameKey
    public static let uniqueName: CoreText.CTFont.NameKey
    public static let fullName: CoreText.CTFont.NameKey
    public static let versionName: CoreText.CTFont.NameKey
    public static let postScriptName: CoreText.CTFont.NameKey
    public static let trademarkName: CoreText.CTFont.NameKey
    public static let manufacturerName: CoreText.CTFont.NameKey
    public static let designerName: CoreText.CTFont.NameKey
    public static let descriptionName: CoreText.CTFont.NameKey
    public static let vendorURLName: CoreText.CTFont.NameKey
    public static let designerURLName: CoreText.CTFont.NameKey
    public static let licenseName: CoreText.CTFont.NameKey
    public static let licenseURLName: CoreText.CTFont.NameKey
    public static let sampleTextName: CoreText.CTFont.NameKey
    public static let postScriptCIDName: CoreText.CTFont.NameKey
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CoreText.CTFont.NameKey, b: CoreText.CTFont.NameKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Attribute : Swift.Hashable, Swift.Equatable {
    public static let url: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let name: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let displayName: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let familyName: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let styleName: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let traits: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let variation: CoreText.CTFont.Attribute
    @available(iOS 11.0, *)
    public static let variationAxes: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let size: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let matrix: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let cascadeList: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let characterSet: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let languages: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let baselineAdjust: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let macintoshEncodings: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let features: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let featureSettings: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let fixedAdvance: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let orientation: CoreText.CTFont.Attribute
    public static let format: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let registrationScope: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let priority: CoreText.CTFont.Attribute
    @available(iOS 3.2, *)
    public static let enabled: CoreText.CTFont.Attribute
    @available(iOS 6.0, *)
    public static let downloadable: CoreText.CTFont.Attribute
    @available(iOS 7.0, *)
    public static let downloaded: CoreText.CTFont.Attribute
    @available(iOS 7.0, *)
    public static let opticalSize: CoreText.CTFont.Attribute
    @available(iOS 13.0, *)
    public static let registrationUserInfo: CoreText.CTFont.Attribute
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: CoreText.CTFont.Attribute, b: CoreText.CTFont.Attribute) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct CTAttributeName {
  public var rawValue: CoreFoundation.CFString
  public static let font: libxetex.CTAttributeName
  public static let kern: libxetex.CTAttributeName
  public static let ligature: libxetex.CTAttributeName
  public static let foregroundColor: libxetex.CTAttributeName
  public static let foregroundColorFromContext: libxetex.CTAttributeName
  public static let paragraphStyle: libxetex.CTAttributeName
  public static let strokeWidth: libxetex.CTAttributeName
  public static let color: libxetex.CTAttributeName
  public static let superscript: libxetex.CTAttributeName
  public static let underlineColor: libxetex.CTAttributeName
  public static let underlineStyle: libxetex.CTAttributeName
  public static let verticalForms: libxetex.CTAttributeName
  public static let CTglyphInfo: libxetex.CTAttributeName
  public static let CTRunDelegate: libxetex.CTAttributeName
  public static let baselineOffset: libxetex.CTAttributeName
  public static let tracking: libxetex.CTAttributeName
}
extension Foundation.URL {
  public var mimeType: Swift.String {
    get
  }
}
@propertyWrapper final public class AtomicValue<Value> : @unchecked Swift.Sendable {
  final public var wrappedValue: Value {
    get
    set
  }
  final public var projectedValue: ((Value) throws -> Value) throws -> () {
    get
  }
  final public var unsafeValue: Value {
    get
  }
  public init(_ lock: libxetex.AtomicValue<Value>.Lock, defaultValue: Value)
  public init<T>(_ lock: libxetex.AtomicValue<Value>.Lock, defaultValue: T? = nil) where Value == T?
  public enum Lock {
    case NSLock
    case NSConditionLock
    case NSRecursiveLock
    public static func == (a: libxetex.AtomicValue<Value>.Lock, b: libxetex.AtomicValue<Value>.Lock) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
extension libxetex.TeXFileQuerier : Swift.Sendable {}
extension libxetex.TeXFileQuerier.QueryError : Swift.Equatable {}
extension libxetex.TeXFileQuerier.QueryError : Swift.Hashable {}
extension libxetex.TeXFontQuerier : Swift.Sendable {}
extension libxetex.TeXFileType : Swift.RawRepresentable {}
extension libxetex.AtomicValue.Lock : Swift.Equatable {}
extension libxetex.AtomicValue.Lock : Swift.Hashable {}
